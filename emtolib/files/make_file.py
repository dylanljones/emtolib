# -*- coding: utf-8 -*
# Author: Dylan Jones
# Date:   2023-07-04
import string
from collections import OrderedDict

from ..common import EmtoFile
from ..directory import walk_emtodirs


class Makefile(EmtoFile):
    def __init__(self, path):
        super().__init__(path)
        self.header = ""
        self.rules = OrderedDict()

    def __post_init__(self):
        self.load(missing_ok=True)

    def clear(self):
        self.header = ""
        self.rules.clear()

    def add_header(self, header):
        self.header += header

    def add_header_line(self, line):
        self.header += line + "\n"

    def add_rule(self, name, cmds=None, sub=None):
        if cmds is None:
            cmds = list()
        if sub is None:
            sub = list()
        if cmds and sub:
            raise ValueError("Cannot define both cmds and sub!")

        if isinstance(cmds, str):
            cmds = [cmds]
        if isinstance(sub, str):
            sub = [sub]
        self.rules[name] = (cmds, sub)

    def add_rule_all(self, exlude=None):
        if exlude is None:
            exlude = list()
        names = [name for name in self.rules.keys() if not exlude or name not in exlude]
        self.add_rule("all", sub=names)

    def get_rule(self, name):
        return self.rules.get(name, ([], []))

    def loads(self, data: str) -> None:
        lines = data.splitlines()
        # Preprocess lines
        name, cmds, sub = "", list(), ""
        for line in lines:
            line = line
            if line.startswith("#") or not line:
                continue
            if line.startswith("\t"):
                cmds.append(line[1:])
                continue
            if ":" in line:
                # Add previous rule
                if name and (cmds or sub):
                    self.add_rule(name, cmds, sub)
                    cmds = []
                # Split name and subtargets
                rule = [x.strip() for x in line.split(":")]
                if len(rule) == 2:
                    name, deps = rule
                    sub = deps.split()
                else:
                    name, sub = rule[0], ""
        # Add the last rule
        if name and (cmds or sub):
            self.add_rule(name, cmds, sub)

    def dumps(self) -> str:
        lines = list()
        if self.header:
            lines.append("\n".join(f"# {h}" for h in self.header.splitlines()))
        lines.append("")
        for name, (cmds, sub) in self.rules.items():
            if sub:
                substr = " ".join(sub)
                lines.append(f"{name}: {substr}")
            else:
                lines.append(f"{name}:")
            for cmd in cmds:
                lines.append(f"\t{cmd}")
            lines.append("")

        return "\n".join(lines)


def get_folders(root):
    folders = list()
    max_depth = 0
    for folder in walk_emtodirs(root):
        relpath = folder.path.relative_to(root)
        depth = len(relpath.parts)
        if max_depth == 0:
            max_depth = depth
        else:
            assert depth == max_depth
        # print(relpath)
        folders.append((folder, relpath))
    folders = sorted(folders, key=lambda x: x[0].path.name)
    return folders, max_depth


def generate_makefile(root):
    slurm_name = "run_emto"
    clean_files = ["slurm*.out", "fort.*", "*.dos", "*.prn", "out_*", "Sig"]
    makefile_path = root / "Makefile"

    makefile = Makefile(makefile_path)
    makefile.clear()
    makefile.add_header_line("-" * 50)
    makefile.add_header_line("Makefile for running all EMTO calculations on ALCC")
    makefile.add_header_line("Generated by emtolib")
    makefile.add_header_line("-" * 50)

    # Gather all emto directories and check depth
    folders, max_depth = get_folders(root)

    # Add sbatch rules
    for i, (folder, relpath) in enumerate(folders):
        # name = folder.path.name.lower()
        name = string.ascii_lowercase[i]
        cmd = f"cd {relpath} && sbatch {slurm_name}"
        makefile.add_rule(name, cmd)

    # Add all rule
    makefile.add_rule_all(exlude=["clean", "cleanslurm"])

    # Add clean rules
    files = ["*/" * max_depth + f"{f}" for f in clean_files]
    makefile.add_rule("clean", "rm -rf " + " ".join(files))
    makefile.add_rule("cleanslurm", "rm -rf " + "*/" * max_depth + "slurm*.out")
    return makefile
